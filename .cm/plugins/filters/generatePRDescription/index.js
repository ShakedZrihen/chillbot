const createJiraTicket = require('./jira.js');

// Parse commit messages
function parseCommitMessages(messages) {
    const commitTypes = {
        feat: [], fix: [], chore: [], docs: [], style: [], refactor: [],
        perf: [], test: [], build: [], ci: [], other: []
    };

    messages.filter(message => !message.includes('Merge branch')).forEach(message => {
        const match = message.match(/^(feat|fix|chore|docs|style|refactor|perf|test|build|ci):/);
        if (match) {
            commitTypes[match[1]].push(message.replace(`${match[1]}:`, '').trim());
        } else {
            commitTypes.other.push(message);
        }
    });

    return commitTypes;
}

// Format commit section
function formatCommitSection(type, commits) {
    return commits.length ? `- **${type}:**\n${commits.map(msg => `  - ${msg}`).join('\n')}\n` : '';
}

function containsNewTests(files) {
    const testPattern = /(test_|spec_|__tests__|_test|_tests|\.test|\.spec)/i;
    const testDirectoryPattern = /[\\/]?(tests|test|__tests__)[\\/]/i;
    const testKeywords = /describe\(|it\(|test\(|expect\(/i; // Common test keywords for JavaScript

    for (const file of files) {
        const { new_file, diff, new_content } = file;

        // Check if the filename indicates it's a test file
        if (testPattern.test(new_file) || testDirectoryPattern.test(new_file)) {
            return true;
        }

        // Check if the diff or new content contains test-related code
        if (testKeywords.test(diff) || testKeywords.test(new_content)) {
            return true;
        }
    }

    return false;
}

function extractUserAdditions(description) {
    const match = description.match(/<!--- user additions --->([\s\S]*?)<!--- user additions end --->/);
    return match ? match[1].trim() : '';
}

// Generate PR description
async function generatePRDescription(branch, pr, repo, source, callback) {
    if (process.env[__filename]) {
        return callback(null, process.env[__filename]);
    }

    const commitTypes = parseCommitMessages(branch.commits.messages);

    const addTests = containsNewTests(source.diff.files) ? 'X' : ' ';
    const testedInDev = pr.comments.some(comment => comment.content.includes('/dev')) ? 'X' : ' ';
    const codeApproved = pr.approvals > 0 ? 'X' : ' ';

    const createTicket = pr.description.includes('[X] Create Jira Ticket') || pr.description.includes('[x] Create Jira Ticket');

    let newTicket = '';

    if (createTicket) {
        try {
            const includeFeatures = branch.commits.messages.some(msg => msg.includes('feat:'));
            const includeBugs = branch.commits.messages.some(msg => msg.includes('fix:'));
            const ticketType = includeFeatures ? 'Task' : includeBugs ? 'Bug' : 'Task';
            const ticketUrl = await createJiraTicket(ticketType, pr.title, pr.url);
            newTicket = `[Jira Ticket](${ticketUrl})`;
            console.log({ newTicket });
        } catch (error) {
            console.error('Failed to create JIRA ticket:', error);
        }
    }

    const jiraTicketMatchInBranch = branch.name.match(/LINBEE-\d+/);
    const jiraTicketMatchInTitle = pr.title.match(/LINBEE-\d+/);
    const jiraTicketMatchInDescription = pr.description.match(/LINBEE-\d+/);
    const jiraTicketExists = newTicket || jiraTicketMatchInBranch || jiraTicketMatchInTitle || jiraTicketMatchInDescription ? 'X' : ' ';

    let gitstreamActions = '### Gitstream Available Actions';
    if (jiraTicketExists === ' ') {
        gitstreamActions += '\n  - [ ] Create Jira Ticket *(check to create using gitStream)*';
    } else if (!jiraTicketMatchInTitle) {
        gitstreamActions += '\n  - [ ] Add Jira Ticket to PR title *(check to add using gitStream)*'
    }

    const changes = Object.entries(commitTypes).map(([type, commits]) => formatCommitSection(type, commits)).join('');
    const userAdditions = extractUserAdditions(pr.description);

    const result = `
  <!--- Auto-generated by gitStream--->
  # ${repo.name}

  ### Summary
  This pull request includes the following changes:
  ${changes}
  
  ### Checklist
  - [${testedInDev}] Tested in dev
  - [${addTests}] Add tests
  - [${codeApproved}] Code Reviewed and approved
  - [${jiraTicketExists}] Attach Jira ticket ${newTicket ? `${newTicket} *created by gitStream*` : ''}
  
  ${gitstreamActions}
  ---
  
  *This PR description section was auto-generated by gitStream.*
  
  <!--- Auto-generated by gitStream end --->
  
  <!--- user additions --->
  ${userAdditions}
  <!--- user additions end --->
  
`;

    process.env[__filename] = result.split('\n').join('\n            ');
    return callback(null, process.env[__filename]);
}

module.exports = { filter: generatePRDescription, async: true };
